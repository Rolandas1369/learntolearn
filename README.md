JS group

[1,2,3,4](items gos to filter function as argument).filter(function(function paramters) => condition of another function) 

[1,2,3,4].filter((a) => a > 2) return [3,4]
[1,2,3,4].reduce((argWhatThisAddedTosUM, addingArgumentFromList) => function or condition)
[1,2,3,4].reduce((argWhatThisAddedTosUM, addingArgumentFromList) => function or condition)
[1,2,3,4].reduce((acc, a) => acc += a) returns 10


[1,2,3,4].fill(arg or function) replaces every array element with on returns [1,1,1,1] is arg 1
[1,2,3,4,[1,2,3]].flat() create new array of nested array
[1,2,3,4].find((a) => a > 2) finds first occurance meeting condition return 3
[1,2,3,4].findIndex((a) => a > 2) finds index of first occurance meeting condition return 2
[1,2,3,4].forEach(a => function or function call) -> doesnt return anything

<<<<<<< HEAD
<a>https://github.com/Rolandas1369/learntolearn/blob/main/GITgroup</a>

First attempt at unknown, commands must be used in first approach.
Second approach (at some time passed?)

Massed Practice
Massed practice is comprised of training or learning sessions that are long and intense as opposed to distributed practice which uses shorter and less intense sessions to impart information to a student or trainee. Massed practice has been shown through research to be ultimately less successful than the distributed practice model.

As an example, it is ultimately more successful in college classwork to stay on top of a subject by frequent reviews of material rather than relying on all-night "cramming" the night before an exam.

LEADS TO: learn by interval, break time or time beetwean task is not clear

Distributed practice (also known as spaced repetition or spaced practice) is a learning strategy, where practice is broken up into a number of short sessions â€“ over a longer period of time. Humans and animals learn items in a list more effectively when they are studied in several sessions spread out over a long period of time, rather than studied repeatedly in a short period of time, a phenomenon called the spacing effect. The opposite, massed practice, consists of fewer, longer training sessions. It is generally a less effective method of learning. For example, when studying for an exam dispersing your studying more frequently over a larger period of time will result in more effective learning than intense study the night before.

LEADS TO: separate task to smaller tasks, not answers question what to do in one big task

Procedural learning
Procedural learning is the act of repeating a complex activity over and over again, until all of the relevant neural systems work together to automatically produce the activity.[3] Distributed practice is the most efficient method of procedural learning. By equally distributing the amount of practice of a given activity over a period of time, you will increase the efficiency of learning that skill.

LEAD TO: can be minutes beatwean sessions

Timeline of consolidation
Synaptic consolidation, when compared to systems consolidation (which is said to take weeks to months to years to be accomplished), is considerably faster. There is evidence to suggest that synaptic consolidation takes place within minutes to hours of memory encoding or learning, and as such is considered the 'fast' type of consolidation.[1] As soon as six hours after training, memories become impervious to interferences that disrupt synaptic consolidation and the formation of long-term memory.

Day Two
Count by days is not best aproach.

Reference can lead to more material, bucket terory can not be applyed directly.

Another case is then material is to hard or unknown.
Resource
<a>https://www.researchgate.net/publication/49249476_Why_Some_Material_Is_Difficult_to_Learn</a>
Limited working memory makes it difficelt to understand. Need to know material before trying, exapmle could be in solving algorithm, part knowloadge of common tools can be bareal for solving solution.

People interacts with Schemas <a>https://en.wikipedia.org/wiki/Schema_(psychology)</a>, this makes sence why only few word from song can create full song in our hear, ok but how schemas are created?

Problems can be solved by only knowing full interaction with information:
a/b = c find b.
If we spliting this info into smaller parts: what is a what is b and what is c, we could not solve this problem, all of them are numbers. We need to know relations in this situation, (aditional information) 
We can move a or b ro right side by multipling oposites.
a/b * b = c * b b is removed
a = c * b
a/b / a = a / c

LEADS TO of course we need to know what is number but also (aditional info beatween numbers)
Addind text to pictures increases cognitive load this means docs are better, than videos. Why, brain needs to interact with picture and text. But how to solve this my guess is to separate result from code. 1) write correct code, then solve task? But how? 
Loop in loop:
for(keyword) i(changing variable) in(keyword) elements(i is assigned to element):
    i is now available in thsi code part, i links to element from list
    print(i)
    Now we can start another loop
    for(keyword) a(changing variable) in(keyword) another_elements(a is element assigned from this list):
        now we have i and new running loop.
         
Resouce 
<a>https://www.obsidianlearning.com/blog/2018/04/cognitive-theories-for-transforming-learning.html</a>

Summary for now
Split big content to smaller parts, maybe it is better to learn from docs (easy to split a lot of data), videos with long courses can have impresion of imposible task of its lenght, try to find similarities in functions or code blocks (adds to schema) group things if you can implement some code few times dont repeat it (progresive learning), implementing new thing (reapeat it by words) more channels are involved. Try to leed to something, use few functions in a row JS example [1,2,3,4].filter((a) => a > 2).reduce((sum, a) => sum += a) maybe not a best case from readers but adds to new layer of thinking. 
=======
Array.from([array], function on array what applied on each element)
[1,2,3,4].includes(1) return true
[1,2,3,4].indexOf(1) return 0
Array.isArray([1,2]) return true
[1,2,3].join() joins array to string "1,2,3"
const abc(a,b,c)
>>>>>>> d9a0ee51d91212ef7c65ee1ed57ffa7f619eebe2
